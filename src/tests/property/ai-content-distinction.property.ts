/**
 * **Feature: workflow-wizard-ui, Property 9: AI Content Distinction**
 * 
 * For any content displayed in the wizard that was generated by an AI agent,
 * the content shall be visually marked with an AI indicator and include a
 * confidence score where applicable.
 * 
 * **Validates: Requirements 12.4**
 */

import { describe, it, expect } from 'vitest';
import fc from 'fast-check';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Agent activity status
 */
type ActivityStatus = 'started' | 'completed' | 'failed';

/**
 * Agent activity record
 */
interface AgentActivity {
  timestamp: string;
  action: string;
  status: ActivityStatus;
  details?: string;
  confidenceScore?: number;
}

/**
 * Gate item for human approval
 */
interface GateItem {
  id: string;
  label: string;
  value: string;
  isAIGenerated: boolean;
  confidenceScore?: number;
}

/**
 * AI content marker for rendering
 */
interface AIContentMarker {
  hasIndicator: boolean;
  hasConfidenceScore: boolean;
  confidenceScore?: number;
}

// ============================================================================
// Pure Functions Under Test
// ============================================================================

/**
 * Check if content is AI-generated based on activity
 * Property 9: AI Content Distinction
 */
function isAIGeneratedContent(activity: AgentActivity): boolean {
  return activity.confidenceScore !== undefined;
}

/**
 * Get all AI-generated activities from a log
 * Property 9: AI Content Distinction
 */
function getAIGeneratedActivities(activities: AgentActivity[]): AgentActivity[] {
  return activities.filter(isAIGeneratedContent);
}

/**
 * Validate that AI content has proper indicators
 * Property 9: AI Content Distinction
 */
function validateAIContentDistinction(
  activities: AgentActivity[]
): { isValid: boolean; missingIndicators: AgentActivity[] } {
  const aiActivities = activities.filter(a => a.confidenceScore !== undefined);
  // All AI activities should have valid confidence scores (0-1 range)
  const missingIndicators = aiActivities.filter(
    a => a.confidenceScore === undefined || a.confidenceScore < 0 || a.confidenceScore > 1
  );
  
  return {
    isValid: missingIndicators.length === 0,
    missingIndicators,
  };
}

/**
 * Check if a gate item has proper AI indicators when AI-generated
 * Property 9: AI Content Distinction
 */
function hasProperAIIndicators(item: GateItem): boolean {
  if (!item.isAIGenerated) {
    // Non-AI content doesn't need indicators
    return true;
  }
  // AI-generated content must have a confidence score
  return item.confidenceScore !== undefined && 
         item.confidenceScore >= 0 && 
         item.confidenceScore <= 1;
}

/**
 * Validate all gate items have proper AI indicators
 * Property 9: AI Content Distinction
 */
function validateGateItemsAIIndicators(
  items: GateItem[]
): { isValid: boolean; invalidItems: GateItem[] } {
  const invalidItems = items.filter(item => !hasProperAIIndicators(item));
  
  return {
    isValid: invalidItems.length === 0,
    invalidItems,
  };
}

/**
 * Get AI content marker for rendering
 * Property 9: AI Content Distinction
 */
function getAIContentMarker(item: GateItem): AIContentMarker {
  return {
    hasIndicator: item.isAIGenerated,
    hasConfidenceScore: item.confidenceScore !== undefined,
    confidenceScore: item.confidenceScore,
  };
}

/**
 * Count AI-generated items in a list
 */
function countAIGeneratedItems(items: GateItem[]): number {
  return items.filter(item => item.isAIGenerated).length;
}

/**
 * Calculate average confidence score for AI-generated items
 */
function calculateAverageConfidence(items: GateItem[]): number | null {
  const aiItems = items.filter(item => item.isAIGenerated && item.confidenceScore !== undefined);
  if (aiItems.length === 0) return null;
  
  const sum = aiItems.reduce((acc, item) => acc + (item.confidenceScore || 0), 0);
  return sum / aiItems.length;
}

// ============================================================================
// Generators
// ============================================================================

const propertyConfig = {
  numRuns: 100,
  verbose: false
};

/**
 * Generator for activity status
 */
const activityStatusGenerator = (): fc.Arbitrary<ActivityStatus> =>
  fc.constantFrom('started', 'completed', 'failed');

/**
 * Generator for valid confidence score (0-1 range)
 */
const validConfidenceScoreGenerator = (): fc.Arbitrary<number> =>
  fc.float({ min: 0, max: 1, noNaN: true });

/**
 * Generator for invalid confidence score (outside 0-1 range)
 */
const invalidConfidenceScoreGenerator = (): fc.Arbitrary<number> =>
  fc.oneof(
    fc.float({ min: Math.fround(-100), max: Math.fround(-0.001), noNaN: true }),
    fc.float({ min: Math.fround(1.001), max: Math.fround(100), noNaN: true })
  );

/**
 * Generator for optional confidence score
 */
const optionalConfidenceScoreGenerator = (): fc.Arbitrary<number | undefined> =>
  fc.oneof(
    validConfidenceScoreGenerator(),
    fc.constant(undefined)
  );

/**
 * Generator for timestamp string
 */
const timestampGenerator = (): fc.Arbitrary<string> =>
  fc.date({ min: new Date('2020-01-01'), max: new Date('2030-12-31') })
    .map(d => d.toISOString());

/**
 * Generator for agent activity
 */
const agentActivityGenerator = (): fc.Arbitrary<AgentActivity> =>
  fc.record({
    timestamp: timestampGenerator(),
    action: fc.string({ minLength: 1, maxLength: 100 }),
    status: activityStatusGenerator(),
    details: fc.option(fc.string({ minLength: 1, maxLength: 200 }), { nil: undefined }),
    confidenceScore: optionalConfidenceScoreGenerator(),
  });

/**
 * Generator for AI-generated activity (always has confidence score)
 */
const aiGeneratedActivityGenerator = (): fc.Arbitrary<AgentActivity> =>
  fc.record({
    timestamp: timestampGenerator(),
    action: fc.string({ minLength: 1, maxLength: 100 }),
    status: activityStatusGenerator(),
    details: fc.option(fc.string({ minLength: 1, maxLength: 200 }), { nil: undefined }),
    confidenceScore: validConfidenceScoreGenerator(),
  });

/**
 * Generator for non-AI activity (no confidence score)
 */
const nonAIActivityGenerator = (): fc.Arbitrary<AgentActivity> =>
  fc.record({
    timestamp: timestampGenerator(),
    action: fc.string({ minLength: 1, maxLength: 100 }),
    status: activityStatusGenerator(),
    details: fc.option(fc.string({ minLength: 1, maxLength: 200 }), { nil: undefined }),
    confidenceScore: fc.constant(undefined),
  });

/**
 * Generator for activity list
 */
const activityListGenerator = (): fc.Arbitrary<AgentActivity[]> =>
  fc.array(agentActivityGenerator(), { minLength: 0, maxLength: 20 });

/**
 * Generator for gate item
 */
const gateItemGenerator = (): fc.Arbitrary<GateItem> =>
  fc.record({
    id: fc.uuid(),
    label: fc.string({ minLength: 1, maxLength: 50 }),
    value: fc.string({ minLength: 1, maxLength: 200 }),
    isAIGenerated: fc.boolean(),
    confidenceScore: optionalConfidenceScoreGenerator(),
  });

/**
 * Generator for valid AI-generated gate item (has proper indicators)
 */
const validAIGateItemGenerator = (): fc.Arbitrary<GateItem> =>
  fc.record({
    id: fc.uuid(),
    label: fc.string({ minLength: 1, maxLength: 50 }),
    value: fc.string({ minLength: 1, maxLength: 200 }),
    isAIGenerated: fc.constant(true),
    confidenceScore: validConfidenceScoreGenerator(),
  });

/**
 * Generator for invalid AI-generated gate item (missing or invalid confidence)
 */
const invalidAIGateItemGenerator = (): fc.Arbitrary<GateItem> =>
  fc.record({
    id: fc.uuid(),
    label: fc.string({ minLength: 1, maxLength: 50 }),
    value: fc.string({ minLength: 1, maxLength: 200 }),
    isAIGenerated: fc.constant(true),
    confidenceScore: fc.oneof(
      fc.constant(undefined),
      invalidConfidenceScoreGenerator()
    ),
  });

/**
 * Generator for non-AI gate item
 */
const nonAIGateItemGenerator = (): fc.Arbitrary<GateItem> =>
  fc.record({
    id: fc.uuid(),
    label: fc.string({ minLength: 1, maxLength: 50 }),
    value: fc.string({ minLength: 1, maxLength: 200 }),
    isAIGenerated: fc.constant(false),
    confidenceScore: fc.constant(undefined),
  });

/**
 * Generator for gate item list
 */
const gateItemListGenerator = (): fc.Arbitrary<GateItem[]> =>
  fc.array(gateItemGenerator(), { minLength: 0, maxLength: 10 });

/**
 * Generator for valid gate item list (all AI items have proper indicators)
 */
const validGateItemListGenerator = (): fc.Arbitrary<GateItem[]> =>
  fc.array(
    fc.oneof(validAIGateItemGenerator(), nonAIGateItemGenerator()),
    { minLength: 0, maxLength: 10 }
  );

// ============================================================================
// Property Tests
// ============================================================================

describe('Property 9: AI Content Distinction', () => {
  
  describe('AI Activity Detection', () => {
    it('should identify AI-generated activities by presence of confidence score', async () => {
      await fc.assert(
        fc.property(
          agentActivityGenerator(),
          (activity) => {
            const isAI = isAIGeneratedContent(activity);
            const hasConfidence = activity.confidenceScore !== undefined;
            
            // Activity is AI-generated if and only if it has a confidence score
            expect(isAI).toBe(hasConfidence);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should always identify activities with confidence scores as AI-generated', async () => {
      await fc.assert(
        fc.property(
          aiGeneratedActivityGenerator(),
          (activity) => {
            expect(isAIGeneratedContent(activity)).toBe(true);
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should never identify activities without confidence scores as AI-generated', async () => {
      await fc.assert(
        fc.property(
          nonAIActivityGenerator(),
          (activity) => {
            expect(isAIGeneratedContent(activity)).toBe(false);
            return true;
          }
        ),
        propertyConfig
      );
    });
  });

  describe('AI Activity Filtering', () => {
    it('should filter only AI-generated activities from a list', async () => {
      await fc.assert(
        fc.property(
          activityListGenerator(),
          (activities) => {
            const aiActivities = getAIGeneratedActivities(activities);
            
            // All returned activities should have confidence scores
            aiActivities.forEach(activity => {
              expect(activity.confidenceScore).toBeDefined();
            });
            
            // Count should match activities with confidence scores
            const expectedCount = activities.filter(a => a.confidenceScore !== undefined).length;
            expect(aiActivities.length).toBe(expectedCount);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should preserve order when filtering AI activities', async () => {
      await fc.assert(
        fc.property(
          activityListGenerator(),
          (activities) => {
            const aiActivities = getAIGeneratedActivities(activities);
            
            // Verify order is preserved
            let lastIndex = -1;
            for (const aiActivity of aiActivities) {
              const currentIndex = activities.indexOf(aiActivity);
              expect(currentIndex).toBeGreaterThan(lastIndex);
              lastIndex = currentIndex;
            }
            
            return true;
          }
        ),
        propertyConfig
      );
    });
  });

  describe('AI Content Validation', () => {
    it('should validate that AI activities have valid confidence scores (0-1 range)', async () => {
      await fc.assert(
        fc.property(
          fc.array(aiGeneratedActivityGenerator(), { minLength: 1, maxLength: 10 }),
          (activities) => {
            const result = validateAIContentDistinction(activities);
            
            // All AI activities with valid confidence scores should pass
            expect(result.isValid).toBe(true);
            expect(result.missingIndicators).toHaveLength(0);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should detect AI activities with invalid confidence scores', async () => {
      await fc.assert(
        fc.property(
          invalidConfidenceScoreGenerator(),
          fc.string({ minLength: 1, maxLength: 50 }),
          (invalidScore, action) => {
            const activity: AgentActivity = {
              timestamp: new Date().toISOString(),
              action,
              status: 'completed',
              confidenceScore: invalidScore,
            };
            
            const result = validateAIContentDistinction([activity]);
            
            expect(result.isValid).toBe(false);
            expect(result.missingIndicators).toHaveLength(1);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should pass validation for empty activity list', () => {
      const result = validateAIContentDistinction([]);
      expect(result.isValid).toBe(true);
      expect(result.missingIndicators).toHaveLength(0);
    });

    it('should pass validation for list with only non-AI activities', async () => {
      await fc.assert(
        fc.property(
          fc.array(nonAIActivityGenerator(), { minLength: 1, maxLength: 10 }),
          (activities) => {
            const result = validateAIContentDistinction(activities);
            
            expect(result.isValid).toBe(true);
            expect(result.missingIndicators).toHaveLength(0);
            
            return true;
          }
        ),
        propertyConfig
      );
    });
  });

  describe('Gate Item AI Indicators', () => {
    it('should require confidence score for AI-generated gate items', async () => {
      await fc.assert(
        fc.property(
          validAIGateItemGenerator(),
          (item) => {
            expect(hasProperAIIndicators(item)).toBe(true);
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should reject AI-generated items without valid confidence score', async () => {
      await fc.assert(
        fc.property(
          invalidAIGateItemGenerator(),
          (item) => {
            expect(hasProperAIIndicators(item)).toBe(false);
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should always accept non-AI gate items regardless of confidence score', async () => {
      await fc.assert(
        fc.property(
          nonAIGateItemGenerator(),
          (item) => {
            expect(hasProperAIIndicators(item)).toBe(true);
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should validate all items in a gate item list', async () => {
      await fc.assert(
        fc.property(
          validGateItemListGenerator(),
          (items) => {
            const result = validateGateItemsAIIndicators(items);
            
            expect(result.isValid).toBe(true);
            expect(result.invalidItems).toHaveLength(0);
            
            return true;
          }
        ),
        propertyConfig
      );
    });
  });

  describe('AI Content Marker Generation', () => {
    it('should generate correct marker for AI-generated items', async () => {
      await fc.assert(
        fc.property(
          validAIGateItemGenerator(),
          (item) => {
            const marker = getAIContentMarker(item);
            
            expect(marker.hasIndicator).toBe(true);
            expect(marker.hasConfidenceScore).toBe(true);
            expect(marker.confidenceScore).toBe(item.confidenceScore);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should generate correct marker for non-AI items', async () => {
      await fc.assert(
        fc.property(
          nonAIGateItemGenerator(),
          (item) => {
            const marker = getAIContentMarker(item);
            
            expect(marker.hasIndicator).toBe(false);
            expect(marker.hasConfidenceScore).toBe(false);
            expect(marker.confidenceScore).toBeUndefined();
            
            return true;
          }
        ),
        propertyConfig
      );
    });
  });

  describe('AI Content Counting', () => {
    it('should correctly count AI-generated items', async () => {
      await fc.assert(
        fc.property(
          gateItemListGenerator(),
          (items) => {
            const count = countAIGeneratedItems(items);
            const expectedCount = items.filter(item => item.isAIGenerated).length;
            
            expect(count).toBe(expectedCount);
            expect(count).toBeGreaterThanOrEqual(0);
            expect(count).toBeLessThanOrEqual(items.length);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should return 0 for empty list', () => {
      expect(countAIGeneratedItems([])).toBe(0);
    });

    it('should return 0 for list with no AI items', async () => {
      await fc.assert(
        fc.property(
          fc.array(nonAIGateItemGenerator(), { minLength: 1, maxLength: 10 }),
          (items) => {
            expect(countAIGeneratedItems(items)).toBe(0);
            return true;
          }
        ),
        propertyConfig
      );
    });
  });

  describe('Average Confidence Calculation', () => {
    it('should calculate correct average for AI items with confidence scores', async () => {
      await fc.assert(
        fc.property(
          fc.array(validAIGateItemGenerator(), { minLength: 1, maxLength: 10 }),
          (items) => {
            const avg = calculateAverageConfidence(items);
            
            expect(avg).not.toBeNull();
            expect(avg).toBeGreaterThanOrEqual(0);
            expect(avg).toBeLessThanOrEqual(1);
            
            // Verify calculation
            const sum = items.reduce((acc, item) => acc + (item.confidenceScore || 0), 0);
            const expectedAvg = sum / items.length;
            expect(avg).toBeCloseTo(expectedAvg, 10);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should return null for empty list', () => {
      expect(calculateAverageConfidence([])).toBeNull();
    });

    it('should return null for list with no AI items', async () => {
      await fc.assert(
        fc.property(
          fc.array(nonAIGateItemGenerator(), { minLength: 1, maxLength: 10 }),
          (items) => {
            expect(calculateAverageConfidence(items)).toBeNull();
            return true;
          }
        ),
        propertyConfig
      );
    });
  });

  describe('Invariant: AI Content Must Have Visual Distinction', () => {
    it('should ensure all AI-generated content has proper indicators', async () => {
      await fc.assert(
        fc.property(
          gateItemListGenerator(),
          (items) => {
            const aiItems = items.filter(item => item.isAIGenerated);
            
            for (const item of aiItems) {
              const marker = getAIContentMarker(item);
              
              // Invariant: AI content must have indicator
              expect(marker.hasIndicator).toBe(true);
              
              // If item has valid confidence score, marker should reflect it
              if (item.confidenceScore !== undefined && 
                  item.confidenceScore >= 0 && 
                  item.confidenceScore <= 1) {
                expect(marker.hasConfidenceScore).toBe(true);
                expect(marker.confidenceScore).toBe(item.confidenceScore);
              }
            }
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should be deterministic - same input always produces same markers', async () => {
      await fc.assert(
        fc.property(
          gateItemGenerator(),
          (item) => {
            const marker1 = getAIContentMarker(item);
            const marker2 = getAIContentMarker(item);
            
            expect(marker1.hasIndicator).toBe(marker2.hasIndicator);
            expect(marker1.hasConfidenceScore).toBe(marker2.hasConfidenceScore);
            expect(marker1.confidenceScore).toBe(marker2.confidenceScore);
            
            return true;
          }
        ),
        propertyConfig
      );
    });

    it('should correctly distinguish AI from non-AI content', async () => {
      await fc.assert(
        fc.property(
          fc.tuple(validAIGateItemGenerator(), nonAIGateItemGenerator()),
          ([aiItem, nonAIItem]) => {
            const aiMarker = getAIContentMarker(aiItem);
            const nonAIMarker = getAIContentMarker(nonAIItem);
            
            // AI content should have indicator, non-AI should not
            expect(aiMarker.hasIndicator).toBe(true);
            expect(nonAIMarker.hasIndicator).toBe(false);
            
            // This ensures visual distinction between AI and non-AI content
            expect(aiMarker.hasIndicator).not.toBe(nonAIMarker.hasIndicator);
            
            return true;
          }
        ),
        propertyConfig
      );
    });
  });
});
